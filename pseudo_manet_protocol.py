# -*- coding: utf-8 -*-
"""WHITEROSE_day3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1owN5hxXscQyE9daK8pyxqoJtlU5jWsoh
"""

# node class to create a node device object
# ip_adrs attribute for  unique identification using ipv4 address
source_data=0
destination_data=0
import random
from pytictoc import TicToc


class node:

  def __init__(self):
    self.data = None
    self.ip_adrs = None
    self.ipv4 = None

  def setIp(self,ipv4):
    self.ip_adrs=ipv4
    addrs=self.ip_adrs.split('.')
    self.ipv4=int(''.join(addrs))

# packet class to give blueprint of the packets send on network
# It has data , source address ,destination address


class packet:

  def __init__(self):
    self.data = None
    self.source = None
    self.destination = None
    self.hop = 0
  def detail(self):
    print("Packet generated by",self.source.ip_adrs,"with destination set to",self.destination.ip_adrs)
    print("Packet data is",self.data)



class zone:


  def __init__(self,zone_num,node_num):
    self.zones = []
    self.zone_num = zone_num
    self.node_num = node_num

    count = 10
    for i in range(zone_num):
      row=[]
      for j in range(zone_num):
        column=[]
        for x in range(node_num):
          ip = str(count)+".0.0."+str(x+1)
          zn = node()
          zn.setIp(ip)
          column.append(zn)
        count=count+1
        random.shuffle(column)
        row.append(column)
      self.zones.append(row)

  def print_zones(self):
      for i in range(self.zone_num) :  
        for j in range(self.zone_num):
          for x in range(self.node_num):
            #print(self.zones[i][j][x].ip_adrs, end="  ") 
            if(self.zones[i][j][x]):
              print('{:10}'.format(self.zones[i][j][x].ip_adrs), end="  ")
            else:
              print('Node Removed')
          print(end="  |  ")
        print("\n\n")

def mobile(zone,x,y,z):
  for i in range(len(zone.zones[x][y])-1):
    zone.zones[x][y][i].ip_adrs=zone.zones[x][y][i+1].ip_adrs
  zone.zones[x][y][-1].ip_adrs="None"



class hashing:

  def __init__(self,sx,sy,dx,dy,graph):
    self.src = graph.zones[sx][sy]
    self.dstn = graph.zones[dx][dy]
    self.string = None

    self.table = {}
    self.path(sx,sy,dx,dy)


  def path(self,x1,y1,x2, y2):

    self.string=str(x1)+"."+str(y1)+"."+str(x2)+"."+str(y2)
    self.table[self.string]=[]
    m_new = 2 * (y2 - y1)  
    slope_error_new = m_new - (x2 - x1) 
    y=y1 
    for x in range(x1,x2+1):  
        output=[x,y]
        self.table[self.string].append(output)
        slope_error_new =slope_error_new + m_new   
        if (slope_error_new >= 0):  
            if y<y2:
              y=y+1
            slope_error_new =slope_error_new - 2 * (x2 - x1)
    

# class prot for our custom defined protocol
destination_data-=2
# it contains the method In and Out which are similar to routeinput() and routeoutput() function in ns3






class prot:

  def __init__(self,Zone,hash,currentPacket,currentNode):
    self.zone = Zone
    self.hash = hash
    self.nodes = Zone.zones[self.hash.table[hash.string][-1][0]][self.hash.table[hash.string][-1][1]]
    self.zoneRoute(currentPacket,currentNode)
    global source_data
    source_data+=1

    
    


  def zoneRoute(self,currentPacket,currentNode):
    
    for pack in self.hash.table[hash.string][:-1]:
      #print("Packet forwarded from",currentNode.ip_adrs,end=' ')
      currentNode=self.zone.zones[pack[0]][pack[1]][0]
      #print("to",currentNode.ip_adrs)
      self.Out(currentPacket,currentNode)
      
  
  # Out function help in forwarding and findinf the path based on ip addresses

  def Out(self,currentPacket,currentNode):

    for pkt in self.nodes[0:]:
      if currentNode.ipv4 == currentPacket.destination.ipv4:
        global destination_data
        destination_data+=1
        #print("Packet reached at required destination",currentNode.ip_adrs)
        currentNode.data = currentPacket.data
        #print("Data received by",currentNode.ip_adrs,"is",currentNode.data)
        
        return currentNode
      else:
        #print("Packet forwarded from",currentNode.ip_adrs,end=" ")
        currentNode=pkt
        #print("to",currentNode.ip_adrs)



  # In function handles the basic operation like Accepting the packet, Discarding the packet, Forwarding the packet



  def In(self,currentPacket,currentNode,zMinRange,zMaxRange):
    
    if currentNode.ipv4 == currentPacket.destination:
      #print("Packet accepted at",currentNode.ip_adrs);
      global destination_data
      global source_data
      source_data=destination_data

    if currentPacket.destination < zMinRange or  currentPacket.destination > zMaxRange:
      #print("Packet discarded at",currentNode.ip_adrs);
      pass
    else:
      routeNode=self.Out(currentPacket,currentNode)
    
      


# main implementation starts
#




No_of_zones=4
device_in_node=1
create = zone(No_of_zones,device_in_node)
hash = hashing(0,0,No_of_zones-1,No_of_zones-1,create)

packet_repeat = 5000

src_dst=[]

t = TicToc()

t.tic()
for i in range(packet_repeat):
  #p.tic()
  info = packet()
  info.data="Hello World"
  info.source=create.zones[0][0][0]
  info.destination=create.zones[1][1][0]
  #info.detail()
  route= prot(create,hash,info,create.zones[0][0][0])
  #p.toc()

print("For",No_of_zones,"zones and ",device_in_node,"nodes in each zone totalling",No_of_zones*No_of_zones*device_in_node,"node devices and",packet_repeat,"packets")
t.toc()


#route= prot(create,hash,info,create.zones[0][0][0])

#print("--------------------------------------------------------------------------------------------------\n\n")
#create.print_zones()
#print("--------------------------------------------------------------------------------------------------\n\n")


#mobile(create,0,1,0)
#route= prot(create,hash,info,create.zones[0][0][0])


#print("--------------------------------------------------------------------------------------------------\n\n")
#print(destination_data,source_data)

